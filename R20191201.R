# 6일차 수업 - 20191201(일)
# 빅데이터 분석 심화

### 다양한 표본 분포 ###
# 1. 카이제곱분포 (χ² 분포, chi-squared distribution)
# 정규분포의 경우 평균(μ)과 분산(σ²) 두 모수를 통해서 확률분포의 모양을 결정지었다면, χ²분포는 자유도(k)가 모수로써 그 모양을 결정하는 요소로 사용된다. (모수 : 확률분포 모양을 결정하는 요인이 되는 것) 모수인 자유도(k)의 변화에 따라 χ² 분포는 자유도가 낮을수록 꼬리가 오른쪽으로 치우친 모양이 된다. 자유도가 증가할수록 점점 정규분포의 형태와 비슷하게 평균을 중심으로 좌우대칭의 형태를 가지게 된다. 
# - 표준정규분포로부터 하나의 확률표본 z를 추출하면, 이 확률표본의 제곱(z²)은 자유도가 χ² 분포(χ²(1))을 따르게 된다.
# - 표준정규분포로부터 독립척으로 추출한 k개의 확률표본 z₁, z₂, z₃...z에 대해 각 확률표본의 제곱은 각각 자유도가 1인 χ²분포를 따르고, 이 확률분포의 제곱의 합은 자유도가 k인 χ²분포를 따르게 됨.
# - 자유도가 k인 χ²분포의 기댓값과 분산 : E(X) = k, Var(X) = 2k

# 테스트) '자유도가 커질수록 정규분포에 가까워진다'는 명제 확인
df <- c(1,3,5,10) # 4가지 자유도
x <- seq(0, 20, by=0.01) # 확률변수
chi2.1 <- dchisq(x, df[1]); chi2.1 # 자유도가 1일 때 카이제곱분포
chi2.3 <- dchisq(x, df[2]); chi2.3 # 자유도가 3일 때 카이제곱분포
chi2.5 <- dchisq(x, df[3]); chi2.5 # 자유도가 5일 때 카이제곱분포
chi2.10 <- dchisq(x, df[4]); chi2.10 # 자유도가 10일 때 카이제곱분포

plot(x,type="n", xlim=c(0,20), ylim=c(0,0.3), main="자유도의 변화에 따른 χ² 분포의 모양 변화", xlab="x", ylab ="", axes = F)
axis(1) # x축
axis(2) # y축
lines(x,chi2.1,lty=1, col="red", lwd=2) #lty : 실의 종류 (1: 실선), lwd : 선의 굵기
lines(x,chi2.3,lty=2, col="orange", lwd=2) #lty : 실의 종류 (2: 굵은 점선) 
lines(x,chi2.5,lty=3, col="blue", lwd=2) #lty : 실의 종류 (3: 가는 점선)
lines(x,chi2.10,lty=4, col="black", lwd=2) #lty : 실의 종류 (4: 선-점선)
legend("topright",paste("df: ",df), lty=1:4, cex=1.0, col=c("red","orange","blue","black")) #범례 만들어주는거. cex : 범례 크기


# 2) t-분포 (student's t-분포)
# 영국의 통계학자인 윌리엄 고셋이 기네스 양조공장에서 맥아를 발효시키는 이스트의 양을 일정하게 하는 연구를 하였으나, 수집할 수 있는 표본의 크기가 너무 작아서, 작은 크기에 대해서 반복해서 연습을 했다. 통계잡지에 student라는 필명으로 t-분포를 발표하게 되었다.
# 두 개의 확률변수 Z와 V가 각각 표준정규분포와 자유도가 k인 χ²분포를 따르고(Z~N(0,1²),V~χ²(k)), 이 두개의 통계량이 서로 독립인 경우 통계량 t를 정리하면, T=Z/sqrt(V)/k 이고, 통계량 T는 자유도가 k인 T분포를 따르게 된다.

df <- c(1,2,8,20) # 자유도
x <- seq(-3,3,by=0.01) # 확률변수
y <- dnorm(x) #  표본정규분포
t.1 <- dt(x, df=df[1]); t.1 #자유도가 1인 t분포를 나타낸다.
t.2 <- dt(x, df=df[2]); t.2 #자유도가 2인 t분포를 나타낸다.
t.8 <- dt(x, df=df[3]); t.8 #자유도가 8인 t분포를 나타낸다.
t.20 <- dt(x, df=df[4]); t.20 #자유도가 2인 t분포를 나타낸다.

plot(x,y, type="l", main="자유도의 변화에 따른 t-분포의 모양 변화",xlab="x", ylab="", col="red",lwd=2,axes=F)
axis(1) # x축
axis(2) # y축
lines(x, t.1, lty=4, col="blue", lwd=2)
lines(x, t.2, lty=3, col="green", lwd=2)
lines(x, t.8, lty=2, col="orange", lwd=2)
lines(x, t.20, lty=6, col="pink", lwd=2)
legend("topright", paste("df : ", df),lty=c(4,3,2,6),cex=1.0, col=c("blue","green","orange", "pink"))


# 3) f-분포
# - 서로 독립인 두 개의 확률변수 V₁, V₂가 각각 자유도가 k₁,k₂인 χ²분포를 따르고(V₁~χ²(k1), V₂~χ²(k2)), 각각의 확률변수를 각각의 자유도로 나눈 통계량을 F=(V1/k1, V2/k2)라고 한다. 이때 통계량 F는 자유도가 (k1,k2)인 F-분포를 따른다.  F=F(k1,k2)
# - F-분포는 서로 다른 두 χ²분포의 비로서, 각 인 χ²분포의 자유도를 모수로 사용하여 두 개의 자유도의 변화에 따라 분포의 모양이 결정된다.

df1 <- c(3, 10) # 자유도 k1
df2 <- c(5, 20) # 자유도 k2
x <- seq(0, 2, by=0.01) #확률변수
f3.5 <- df(x,df1[1],df2[1]); f3.5 # 자유도가 3, 5인 F-분포
f3.20 <- df(x,df1[1],df2[2]); f3.20 # 자유도가 3, 20인 F-분포
f10.5 <- df(x,df1[2],df2[1]); f10.5 # 자유도가 10, 5인 F-분포
f10.20 <- df(x,df1[2],df2[2]); f10.20 # 자유도가 10, 20인 F-분포

plot(x, type="n", xlim=c(0,2), ylim=c(0,0.9), xlab="x",ylab="",main="자유도의 변화에 따른 F-분포의 변화", axes=F)
axis(1) # x축
axis(2) # y축
lines(x, f3.5, lty=1, col="red", lwd=2)
lines(x, f3.20, lty=2, col="orange", lwd=2)
lines(x, f10.5, lty=3, col="green", lwd=2)
lines(x, f10.20, lty=4, col="blue", lwd=2)
legend("topright", paste("df : ", c("3,5","3,20", "10,5", "10,20")),lty=c(1,2,3,4),cex=1.0, col=c("red","orange","blue","black"))

# 분석결과 : f-분포는 꼬리가 오른쪽으로 길게 늘어진 형태를 하고 있다.
# F- 분포는 두 개의 독립인 χ²분포의 비율을 이용하여 것으로 두 모집단의 분산 비율을 알고자 할 때 사용한다.

##### 준비학습(함수) #####
# 1. 모집단의 분산
# 문제1) 야구공을 만드는 회사에서는 KBO가 정한 반발계수에 맞춰서 새롭게 공 10개를 시제품으로 만들어 다음과 같이 관찰

options(digits =4)
cor = c(0.4196, 0.4172, 0.4237, 0.4182, 0.4324, 0.4365, 0.4354, 0.4156, 0.4172, 0.4414)
m <- mean(cor); m # 평균 : 0.4257
dev <- cor-m ; dev # 편차
num <- sum(dev^(2)); num # 편차의 제곱의 합
denum <- length(cor); denum # 길이 : 10
denum2 <- length(cor)-1; denum2 # (자유도를 고려한) 길이 : 9

var.p <- num / denum; var.p #8.461e-05
var.s <- num / denum2; var.s #9.401e-05

# 위의 예는 반발계수에 대한 분산을 구했지만, 공의 크기, 공의 무게에 대해서도 분산을 구해야 한다면 위의 예와 똑같은 코드를 여러번 반복 작성해야 한다. 이러한 문제를 해결하기 위해서 한번 만들어 두면 똑같은 코드에 대해서 반복적으로 여러 번 사용할 수 있는 함수가 필요하다.

# 2. 모집단의 분산을 구하는 사용자 정의 함수
var.p <- function(x) {
  n <- length(x) -1
  m <- mean(x)
  num <- sum((x-m)^2)
  var <- num/n
  return (var)
}

cor = c(0.4196, 0.4172, 0.4237, 0.4182, 0.4324, 0.4365, 0.4354, 0.4156, 0.4172, 0.4414)
var.p(cor) #9.401e-05

radius = c(234,234,234,233,233,233,233,231,232,231);
var.p(radius) #1.289

weight <- c(146.3, 146.4, 144.1, 146.7, 145.2, 144.1, 143.3, 147.3, 146.7, 147.3)
var.p(weight) #2.12

# 3. 사용자 정의 함수에서 여러개의 전달인자(매개변수)의 기본 전달인자
options(digists = 4)

var.p2 <- function(x, na_rm=F){
  if(na_rm==T){
    x <- x[!is.na(x)]
  }
  
  n <- length(x)
  m <- mean(x)
  num <- sum((x-m)^2, na.rm = na_rm)
  var <- num / n
  return (var)
}

radius <- c(234,234,234,233,233,233,NA,231,232,231)

var(radius) #NA
var(radius, na.rm = T) # 1.444

var.p2(radius) #NA
var.p2(radius,na_rm = T) # 1.284

##################
### 추정

# 추측통계학(inferential statistics) : 표본으로부터 특성을 관찰하여 모집단의 특성을 유추
# 1. 추정(estimation) : 모집단으로부터 추출된 표본으로부터 특성을 파악하여 모수를 유추하는 방법
# 2. 가설검정(hypothesis testing) : 모수에 대해 가설을 수립하고, 이로부터 어떤 가설을 채택할 것인지를 통계적으로 결정하는 방법

# 추정(estimation)
# 1. 점추정(point estimation) : 표본의 특성을 나타내는 통계량 중에서 모수를 유추하는 데에 있어 최적의 계산식을 통해 하나의 추정값을 구하는 방법, 점추정은 표본으로부터 계산되는 값이기에 추출되는 표본에 따라 오류가 발생할 수 있음.
# 2. 구간추정(interval estimation) : 점추정의 단점을 보완해서, 하나의 점(값)이 아닌 모수의 참값이 포함될 것으로 기대되는 구간을 측정하는 방법

# 추정량(estimator) : 알고자 하는 모수를 추측하기 위해 표본으로부터 관찰된 값으로 계산되는 표본의 통계량
# 추정량의 예) 표본의 특성인 표본평균, 표본분산 등의 통계량은 각각 모집단의 평균과 분산을 추정하는 통계량
# 추정치(estimate) : 표본으로부터 관측된 자료를 통해 계산된 추정량의 결과

# 불편성과 불편추정량
# 불편성(unbiasedness) : 추정량이 갖춰야될 기본적인 성질로 한쪽으로 치우쳐지지 않음을 의미한다. 추정량의 기댓값이 모수와 같음을 의미한다.
# 불편추정량(unbiasedness estimator) : 불편성을 만족하는 추정량

# 유효성(efficiency) : 만일 여러 개의 불편추정량이 있을 경우, 더 좋은 추정량을 결정하는 것
# 유효한 추정량 : 모수 θ에 대한 두 불편추정량 θ1, θ2가 있다. 이들에 대해서 각각의 분산을 var(θ1), var(θ2) 라고 할 때 다음을 만족한다면 θ1이 θ2보다 더 유효한 추정량이라고 할 수 있음 var(θ1) < var(θ2)

# 문제1) 유효성
# 모집단이 표준정규분포인 경우 두 추정량 v1, v2의 분포를 작성하고 형태를 확인

x <- seq(-3,3,by=0.01)
y <- dnorm(x) # 표준정규분포
y.1 <- dnorm(x, sd=sqrt(1/3)) # 표준편차 6/18인 정규분포
y.2 <- dnorm(x, sd=sqrt(7/18)) # 표준편차 7/18인 정규분포
pnorm(0.1, sd=sqrt(1/3))-pnorm(-0.1, sd=sqrt(1/3)) #0.1375
pnorm(0.1, sd=sqrt(7/18))-pnorm(-0.1, sd=sqrt(7/18)) # 0.1274

plot(x,y,type="l", main="분산이 다른 두 추정량의 분포",ylim=c(0,0.8),col="orange", lwd=3)
lines(x,y.1, col="red", lwd=3, lty=2)
lines(x,y.2, col="blue", lwd=3, lty=3)

# 모평균 μ, 모분산 σ²인 모집단으로부터 추출한 확률표본에 대해 모평균의 추정량에 대한 두 개의 추정량 Y1,Y2 의 분산이 각각 1/3(6/18), 7/18으로 Y1이 근사하게 작음을 알 수 있고, Y2보다 좀더 유효한 추정량이라고 할 수 있다. 

# 문제2) 유효성의 모의실험
# 표준정규분포를 이루는 모집단에서 3개의 확률표본을 추출해서 앞서 사용한 두 추정량 Y1, Y2를 구하는 것을 1000번 시행했을 때의 각각의 추정량의 분포를 확인
# 추정량의 계산은 Y1의 경우에 R내장함수 mean()을 사용하여 구하고, Y2인 경우 이를 계산하기 위한 함수 mean.seq() 함수를 만들어서 사용

options(digits = 4)
set.seed(5)

mean.seq <- function(x){
  n <- length(x)
  sum <- 0
  n2 <- 0
  for(i in 1:n){
    newx<- i*x[i]
    sum <- sum + newx
    n2 <- n2 + i
  }
  return (sum/n2)
}

y1 <- rep(NA,1000) # 초기화
y2 <- rep(NA,1000) # 초기화

for(i in 1:1000) {
  smp <- rnorm(3)
  y1[i] <- mean(smp)
  y2[i] <- mean.seq(smp)
}

n1 <- length(y1[y1>-0.1 & y1 < 0.1]); n1 #163
n2 <- length(y2[y2>-0.1 & y2 < 0.1]); n2 #135

data.frame(mean=mean(y1), var=var(y1), n=n1) # 분산 6/18

data.frame(mean=mean(y2), var=var(y2), n=n2) # 분산 7/18

par(mfrow=c(1,2))
hist(y1, probability=T,xlim=c(-2,2), ylim=c(0,0.65), main="(x1+x2+x3/3)", cex.main=2, col="orange", border="red")
hist(y2, probability=T,xlim=c(-2,2), ylim=c(0,0.65), main="(1*x1+2*x2+6*x3/3)", cex.main=2, col="orange", border="red")

# Y1과 Y2의 불편추정량 측정에서 미세하지만, y1의 히스토그램이 y2의 히스토그램보다 평균 주변의 높이가 높음을 알 수 있다. 따라서 Y1이 Y2보다 더 유효한 불편추정량임을 알 수 있다.

# 일치성(CONSISTENCY) : 표본의 크기와 관련이 있는 추정량의 성질, 이를 만족하는 추정량을 일치추정량이라고 함
# 일치추정량 - 표본의 크기가 커질수록 추정량의 추정치가 모수와 확률적으로 같아짐을 의미한다. 따라서, 모평균, 모분산, 모비율에 대한 추정량인 표본평균, 표본분산, 표본비율은 일치추정량이다. 표본표준편차는 불편추정량은 아니지만, 표본의 크기가 커질수록 모표준편차와 차이가 줄어들어 모표준편차의 추정량으로 사용하고, 이는 표본표준편차의 일치성을 이용한 것이다.

# 표준오차(standard error) : 추정에서는 추정량의 표준편차에 대해 그 값이 작으면 모평균 추정에 대한 신뢰도가 높아지고, 표준편차가 커지면 신뢰도가 작아지게 된다. 즉, 추정에서는 표준오차는 추정량의 신뢰도가 된다.
# 표준오차는 SE(θ) = σ/sqrt(n)

# 모비율(P)의 정추정 : 모집단에서 원하는 결과가 나타날 비율 P에 대한 정추정
# 모비율 P에 대한 추정량은 표본비율 phat을 이용
# 표본비율 phat은 모집단으로부터 n개의 확률표본을 추출했을 때, 원하는 결과의 계수 x의 비율, phat = X/n
# 결과의 갯수? 계수? X는 시행횟수가 n이고, 성공확률이 모집단에서 원하는 결과가 나타날 비율 p인 이항분포를 따르는 확률변수
# phat은 평균(기댓값), E(X) = phat의 기댓값은 모비율 P이고, phat은 불편추정량임.
# 표준오차는 SE(phat) =sqrt(P)(1-p)/n

# 문제3) 모비율에 대한 점추정 문제
# 주사위를 던져 짝수의 눈이 나올 비율을 정추정하려고 한다. 이 때 표본의 크기는 3이고, 복원추출하여(주사위를 3번 던져) 표본비율들의 분포를 구한다.

library(prob) # 왜 안되지ㅠㅠ 뭘 설치 안한거지ㅠㅠ
n <-3

#주사위를 세번 던져서 나올 수 있는 모든 경우의 수를 smps.all에 데이터프레임으로 지명
smps.all <- rolldie(n)

#is.even()함수는 짝수는 TRUE, 홀수는 FALSE로 리턴하는 함수
# 1:T, 0:F
is.even <- function(x) {
  return (!x%%2)
}

# var.p()함수는 모분산을 계산하여 리턴하는 함수
var.p <- function(x){
  return (sum((x - mean(x))^2/length(x)))
}

# 짝수의 개수를 구하는 함수
p.even <- function(x,s,size=3){
  return (sum(is.even(x)) / s.size)
}

# 각 행별로 p.even 함수를 적용하여 행별 짝수의 비율을 저장
phat <- apply(smps.all, 1, p.even)

mean(phat) #표본비율의 기댓값, 0.5
var.p(phat) # 표본분산, 0.08333
sqrt(var.p(phat)) # 표준편차, 0.2887

p.p <- 0.5
p.p*(1-p.p) /3 # 표준오차
